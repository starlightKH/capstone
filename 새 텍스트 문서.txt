if __name__ == "__main__":
    # 명령행에서 입력 매개변수를 가져옵니다.
    args = get_args()

    # 클린 오디오 파일과 노이즈 오디오 파일 경로를 변수에 저장합니다.
    clean_file = args.clean_file
    noise_file = args.noise_file

    # 클린 오디오 파일의 메타데이터를 가져옵니다.
    metadata = sf.info(clean_file)

    # 클린 오디오의 인코딩 유형을 결정합니다.
    for item in EncodingType:
        if item.description == metadata.subtype_info:
            encoding_type = item

    # 클린 오디오와 노이즈 오디오를 읽어옵니다.
    clean_amp, clean_samplerate = sf.read(clean_file, dtype=encoding_type.dtype)
    noise_amp, noise_samplerate = sf.read(noise_file, dtype=encoding_type.dtype)

    # 클린 오디오의 RMS 값을 계산합니다.
    clean_rms = cal_rms(clean_amp)

    # 노이즈 오디오 중에서 임의의 위치에서 클린 오디오와 같은 길이의 노이즈를 추출합니다.
    start = random.randint(0, len(noise_amp) - len(clean_amp))
    divided_noise_amp = noise_amp[start : start + len(clean_amp)]
    noise_rms = cal_rms(divided_noise_amp)

    # 입력으로 받은 SNR을 이용하여 조정된 노이즈의 RMS 값을 계산합니다.
    snr = args.snr
    adjusted_noise_rms = cal_adjusted_rms(clean_rms, snr)

    # 조정된 노이즈를 계산하고 클린 오디오에 더하여 혼합된 오디오를 생성합니다.
    adjusted_noise_amp = divided_noise_amp * (adjusted_noise_rms / noise_rms)
    mixed_amp = clean_amp + adjusted_noise_amp

    # 클리핑을 방지하기 위해 혼합된 오디오가 최대/최소 임계값을 벗어나면 조절합니다.
    max_limit = encoding_type.maximum
    min_limit = encoding_type.minimum
    if mixed_amp.max(axis=0) > max_limit or mixed_amp.min(axis=0) < min_limit:
        if mixed_amp.max(axis=0) >= abs(mixed_amp.min(axis=0)):
            reduction_rate = max_limit / mixed_amp.max(axis=0)
        else:
            reduction_rate = min_limit / mixed_amp.min(axis=0)
        mixed_amp = mixed_amp * (reduction_rate)
        clean_amp = clean_amp * (reduction_rate)

    # 혼합된 오디오를 지정된 파일에 저장합니다.
    save_waveform(
        args.output_mixed_file, mixed_amp, clean_samplerate, encoding_type.subtype
    )
